{"version":3,"sources":["node_modules/tiled-canvas/src/helpers.ts","node_modules/micro-memoize/es/utils.js","node_modules/micro-memoize/es/index.js","node_modules/tiled-canvas/src/canvas.ts","node_modules/tiled-canvas/src/geometry.ts","node_modules/tiled-canvas/src/loadMap.ts","node_modules/tiled-canvas/src/index.ts","src/example1.ts"],"names":["hasOwnProperty","Object","prototype","assign","target","source","index","arguments","length","undefined","key","call","cloneArray","arrayLike","array","Array","createAreKeysEqual","isEqual","keys1","keys2","createGetKeyIndex","isMatchingKey","areKeysEqual","allKeys","keysToMatch","isSameValueZero","object1","object2","onCacheOperation","cacheIgnored","optionsIgnored","memoizedIgnored","orderByLru","value","startingIndex","createSetPromiseHandler","options","getKeyIndex","cache","memoized","keys","values","then","onCacheHit","onCacheChange","catch","error","keyIndex","splice","_objectWithoutPropertiesLoose","excluded","i","sourceKeys","indexOf","memoize","fn","isMemoized","_ref","_ref$isEqual","_ref$isPromise","isPromise","_ref$maxSize","maxSize","_ref$onCacheAdd","onCacheAdd","_ref$onCacheChange","_ref$onCacheHit","transformKey","extraOptions","normalizedOptions","setPromiseHandler","shouldCloneArguments","size","args","normalizedArgs","pop","newKey","newValue","apply","defineProperties","configurable","get","cacheSnapshot"],"mappings":"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","file":"example1.1ac3e8cb.map","sourceRoot":"..","sourcesContent":["import { TileLayer, Layer, GroupLayer, ImageLayer, ObjectLayer } from './model/tiled';\nimport {\n    BaseObject,\n    TilemapObject,\n    Point,\n    Polygon,\n    Polyline,\n    Rectangle,\n    Text,\n    Ellipse\n} from './model/tiled-geometry-objects';\n\nexport const isTileLayer = (layer: Layer): layer is TileLayer => layer.type === 'tilelayer';\nexport const isGroupLayer = (layer: Layer): layer is GroupLayer => layer.type === 'group';\nexport const isObjectLayer = (layer: Layer): layer is ObjectLayer => layer.type === 'objectgroup';\nexport const isImageLayer = (layer: Layer): layer is ImageLayer => layer.type === 'imagelayer';\n\nexport const isTilemapObject = (obj: BaseObject): obj is TilemapObject => !!(obj as TilemapObject).gid;\nexport const isEllipse = (obj: BaseObject): obj is Ellipse => !!(obj as Ellipse).ellipse;\nexport const isPoint = (obj: BaseObject): obj is Point => !!(obj as Point).point;\nexport const isPolygon = (obj: BaseObject): obj is Polygon => !!(obj as Polygon).polygon;\nexport const isPolyline = (obj: BaseObject): obj is Polyline => !!(obj as Polyline).polyline;\nexport const isText = (obj: BaseObject): obj is Text => !!(obj as Text).text;\nexport const isRectangle = (obj: BaseObject): obj is Rectangle =>\n    !isTilemapObject(obj) && !isEllipse(obj) && !isPoint(obj) && !isPolygon(obj) && !isPolyline(obj) && !isText(obj);\n","// types\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @function assign\n *\n * @description\n * merge the sources into the target, as you would with Object.assign()\n *\n * @param {Object} target object to merge into\n * @param  {...Array<Object>} sources the sources to merge into the target\n * @returns {Object} the merged object\n */\n\nexport var assign = function assign(target) {\n  var source;\n\n  for (var index = 0; index < (arguments.length <= 1 ? 0 : arguments.length - 1); index++) {\n    source = index + 1 < 1 || arguments.length <= index + 1 ? undefined : arguments[index + 1];\n\n    if (source && typeof source === 'object') {\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n  }\n\n  return target;\n};\n/**\n * @function cloneArray\n *\n * @description\n * clone the array-like object and return the new array\n *\n * @param {Array<any>|Arguments} arrayLike the array-like object to clone\n * @returns {Array<any>} the clone of the array\n */\n\nexport var cloneArray = function cloneArray(arrayLike) {\n  var length = arrayLike.length;\n\n  if (!length) {\n    return [];\n  }\n\n  if (length === 1) {\n    return [arrayLike[0]];\n  }\n\n  if (length === 2) {\n    return [arrayLike[0], arrayLike[1]];\n  }\n\n  if (length === 3) {\n    return [arrayLike[0], arrayLike[1], arrayLike[2]];\n  }\n\n  var array = new Array(length);\n\n  for (var index = 0; index < length; index++) {\n    array[index] = arrayLike[index];\n  }\n\n  return array;\n};\nexport var createAreKeysEqual = function createAreKeysEqual(isEqual\n/**\n * @function areKeysEqual\n *\n * @description\n * are the keys shallowly equal to one another\n *\n * @param {Array<any>} keys1 the keys array to test against\n * @param {Array<any>} keys2 the keys array to test\n * @returns {boolean} are the keys shallowly equal\n */\n) {\n  return function (keys1, keys2) {\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (var index = 0, length = keys1.length; index < length; index++) {\n      if (!isEqual(keys1[index], keys2[index])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n};\nexport var createGetKeyIndex = function createGetKeyIndex(isEqual, isMatchingKey) {\n  var areKeysEqual = typeof isMatchingKey === 'function' ? isMatchingKey : createAreKeysEqual(isEqual);\n  /**\n   * @function getKeyIndex\n   *\n   * @description\n   * get the index of the matching key\n   *\n   * @param {Array<Array<any>>} allKeys the list of all available keys\n   * @param {Array<any>} keysToMatch the key to try to match\n   *\n   * @returns {number} the index of the matching key value, or -1\n   */\n\n  return function (allKeys, keysToMatch) {\n    for (var index = 0; index < allKeys.length; index++) {\n      if (areKeysEqual(allKeys[index], keysToMatch)) {\n        return index;\n      }\n    }\n\n    return -1;\n  };\n};\n/**\n * @function isSameValueZero\n *\n * @description\n * are the objects equal based on SameValueZero\n *\n * @param {any} object1 the first object to compare\n * @param {any} object2 the second object to compare\n * @returns {boolean} are the two objects equal\n */\n\nexport var isSameValueZero = function isSameValueZero(object1, object2) {\n  return object1 === object2 || object1 !== object1 && object2 !== object2;\n};\nexport var onCacheOperation = function onCacheOperation(cacheIgnored, optionsIgnored, memoizedIgnored) {};\n/**\n * @function orderByLru\n *\n * @description\n * order the array based on a Least-Recently-Used basis\n *\n * @param {Array<any>} array the array to order\n * @param {any} value the value to assign at the beginning of the array\n * @param {number} startingIndex the index of the item to move to the front\n */\n\nexport var orderByLru = function orderByLru(array, value, startingIndex) {\n  var index = startingIndex;\n\n  while (index--) {\n    array[index + 1] = array[index];\n  }\n\n  array[0] = value;\n};\n/**\n * @function createSetPromiseHandler\n *\n * @description\n * update the promise method to auto-remove from cache if rejected, and if resolved then fire cache hit / changed\n *\n * @param {Options} options the options for the memoized function\n * @param {function(Cache, function): function} memoized the memoized function\n */\n\nexport var createSetPromiseHandler = function createSetPromiseHandler(options) {\n  var getKeyIndex = createGetKeyIndex(options.isEqual, options.isMatchingKey);\n  return function (cache, memoized) {\n    var key = cache.keys[0];\n    cache.values[0] = cache.values[0].then(function (value) {\n      options.onCacheHit(cache, options, memoized);\n      options.onCacheChange(cache, options, memoized);\n      return value;\n    }).catch(function (error) {\n      var keyIndex = getKeyIndex(cache.keys, key);\n\n      if (~keyIndex) {\n        cache.keys.splice(keyIndex, 1);\n        cache.values.splice(keyIndex, 1);\n      }\n\n      throw error;\n    });\n  };\n};","function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n// types\n// utils\nimport { assign, cloneArray, createGetKeyIndex, createSetPromiseHandler, isSameValueZero, onCacheOperation, orderByLru } from './utils';\n/**\n * @function memoize\n *\n * @description\n * get the memoized version of the method passed\n *\n * @param {function} fn the method to memoize\n * @param {Object} [options={}] the options to build the memoizer with\n * @param {boolean} [options.isEqual=isSameValueZero] the method to compare equality of keys with\n * @param {number} [options.maxSize=1] the number of items to store in cache\n * @returns {function} the memoized method\n */\n\nexport default function memoize(fn, options) {\n  // if it is a memoized method, don't re-memoize it\n  if (fn.isMemoized) {\n    return fn;\n  }\n\n  var _ref = options || {},\n      _ref$isEqual = _ref.isEqual,\n      isEqual = _ref$isEqual === void 0 ? isSameValueZero : _ref$isEqual,\n      isMatchingKey = _ref.isMatchingKey,\n      _ref$isPromise = _ref.isPromise,\n      isPromise = _ref$isPromise === void 0 ? false : _ref$isPromise,\n      _ref$maxSize = _ref.maxSize,\n      maxSize = _ref$maxSize === void 0 ? 1 : _ref$maxSize,\n      _ref$onCacheAdd = _ref.onCacheAdd,\n      onCacheAdd = _ref$onCacheAdd === void 0 ? onCacheOperation : _ref$onCacheAdd,\n      _ref$onCacheChange = _ref.onCacheChange,\n      onCacheChange = _ref$onCacheChange === void 0 ? onCacheOperation : _ref$onCacheChange,\n      _ref$onCacheHit = _ref.onCacheHit,\n      onCacheHit = _ref$onCacheHit === void 0 ? onCacheOperation : _ref$onCacheHit,\n      transformKey = _ref.transformKey,\n      extraOptions = _objectWithoutPropertiesLoose(_ref, [\"isEqual\", \"isMatchingKey\", \"isPromise\", \"maxSize\", \"onCacheAdd\", \"onCacheChange\", \"onCacheHit\", \"transformKey\"]);\n\n  var normalizedOptions = assign({}, extraOptions, {\n    isEqual: isEqual,\n    isMatchingKey: isMatchingKey,\n    isPromise: isPromise,\n    maxSize: maxSize,\n    onCacheAdd: onCacheAdd,\n    onCacheChange: onCacheChange,\n    onCacheHit: onCacheHit,\n    transformKey: transformKey\n  });\n  var getKeyIndex = createGetKeyIndex(isEqual, isMatchingKey);\n  var setPromiseHandler = createSetPromiseHandler(normalizedOptions);\n  var shouldCloneArguments = !!(transformKey || isMatchingKey);\n  var cache = {\n    keys: [],\n\n    get size() {\n      return cache.keys.length;\n    },\n\n    values: []\n  };\n  var keys = cache.keys,\n      values = cache.values;\n  /**\n   * @function memoized\n   *\n   * @description\n   * the memoized version of the method passed\n   *\n   * @param {...Array<any>} key the arguments passed, which create a unique cache key\n   * @returns {any} the value of the method called with the arguments\n   */\n\n  function memoized() {\n    var args = arguments;\n    var normalizedArgs = shouldCloneArguments ? cloneArray(args) : args;\n    var key = transformKey ? transformKey(normalizedArgs) : normalizedArgs;\n    var keyIndex = getKeyIndex(keys, key);\n\n    if (~keyIndex) {\n      onCacheHit(cache, normalizedOptions, memoized);\n\n      if (keyIndex) {\n        orderByLru(keys, keys[keyIndex], keyIndex);\n        orderByLru(values, values[keyIndex], keyIndex);\n        onCacheChange(cache, normalizedOptions, memoized);\n      }\n    } else {\n      if (keys.length >= maxSize) {\n        keys.pop();\n        values.pop();\n      }\n\n      var newKey = shouldCloneArguments ? key : cloneArray(normalizedArgs);\n      var newValue = fn.apply(this, args);\n      orderByLru(keys, newKey, keys.length);\n      orderByLru(values, newValue, values.length);\n\n      if (isPromise) {\n        setPromiseHandler(cache, memoized);\n      }\n\n      onCacheAdd(cache, normalizedOptions, memoized);\n      onCacheChange(cache, normalizedOptions, memoized);\n    }\n\n    return values[0];\n  }\n\n  Object.defineProperties(memoized, {\n    cache: {\n      configurable: true,\n      get: function get() {\n        return cache;\n      }\n    },\n    cacheSnapshot: {\n      configurable: true,\n      get: function get() {\n        return {\n          keys: cloneArray(cache.keys),\n          size: cache.size,\n          values: cloneArray(cache.values)\n        };\n      }\n    },\n    isMemoized: {\n      configurable: true,\n      get: function get() {\n        return true;\n      }\n    },\n    options: {\n      configurable: true,\n      get: function get() {\n        return normalizedOptions;\n      }\n    }\n  });\n  return memoized;\n}","import { TmxJson, Layer, TsxJson, TileLayer, GroupLayer, ObjectLayer, ImageLayer } from './model/tiled';\nimport {\n    isTileLayer,\n    isGroupLayer,\n    isObjectLayer,\n    isImageLayer,\n    isEllipse,\n    isPoint,\n    isPolygon,\n    isPolyline,\n    isRectangle,\n    isText,\n    isTilemapObject\n} from './helpers';\n\nimport memoize from 'micro-memoize';\n\nconst getAnimatedTile = memoize(\n    (animationTime: number, { tiles }: TsxJson) =>\n        memoize(\n            (tileIndex: number) => {\n                const baseTileIndex = tileIndex & (0x0fffffff - 1);\n                const rotation = tileIndex & 0xf0000000;\n\n                if (!tiles || !tiles[baseTileIndex] || !tiles[baseTileIndex].animation) {\n                    return tileIndex;\n                }\n\n                const animation = tiles[baseTileIndex].animation;\n                const animationTotal = animation.reduce((sum, item) => sum + item.duration, 0);\n\n                animationTime = animationTime % animationTotal;\n                let time = 0;\n                for (const frame of animation) {\n                    time += frame.duration;\n                    if (time >= animationTime) {\n                        return (frame.tileid | rotation) + 1;\n                    }\n                }\n                return tileIndex;\n            },\n            { maxSize: Number.POSITIVE_INFINITY }\n        ),\n    { maxSize: 2 } // for \"last render\" and \"current render\"\n);\n\nexport interface DrawCanvasLayerArgs<LayerType extends Layer = Layer> {\n    layer: LayerType;\n    context: CanvasRenderingContext2D;\n    tileSet: HTMLImageElement;\n    tmxJson: TmxJson;\n    tsxJson: TsxJson;\n    animationTime?: number;\n    /** if lastAnimationTime is set, only tiles that changed animation state between animationTime and lastAnimationTime will be drawn */\n    lastAnimationTime?: number;\n}\n\nexport function drawCanvasLayer(args: DrawCanvasLayerArgs) {\n    const { layer } = args;\n    if (isTileLayer(layer)) {\n        drawTileLayer(args as DrawCanvasLayerArgs<TileLayer>);\n    } else if (isGroupLayer(layer)) {\n        drawGroupLayer(args as DrawCanvasLayerArgs<GroupLayer>);\n    } else if (isObjectLayer(layer)) {\n        drawObjectLayer(args as DrawCanvasLayerArgs<ObjectLayer>);\n    } else if (isImageLayer(layer)) {\n        drawImageLayer(args as DrawCanvasLayerArgs<ImageLayer>);\n    }\n}\n\nfunction drawTileLayer(args: DrawCanvasLayerArgs<TileLayer>) {\n    const {\n        layer,\n        context,\n        tileSet,\n        tmxJson: { width, height },\n        tsxJson,\n        animationTime = 0,\n        lastAnimationTime\n    } = args;\n\n    if (!Array.isArray(layer.data)) {\n        return;\n    }\n\n    const getTileIndex = getAnimatedTile(animationTime, tsxJson);\n    const getLastTileIndex = lastAnimationTime ? getAnimatedTile(lastAnimationTime, tsxJson) : getTileIndex;\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const gridIndex = y * width + x;\n            if (layer.data[gridIndex] === 0) {\n                continue;\n            }\n            const tileIndex = getTileIndex(layer.data[gridIndex]);\n            if (lastAnimationTime) {\n                const lastTileIndex = getLastTileIndex(layer.data[gridIndex]);\n                if (lastTileIndex === tileIndex) {\n                    continue;\n                }\n            }\n            context.save();\n            drawCanvasTile({ x, y, tileIndex, context, tileSet, layer, tsxJson });\n            context.restore();\n        }\n    }\n}\n\nfunction drawGroupLayer(args: DrawCanvasLayerArgs<GroupLayer>) {\n    const { layer } = args;\n\n    if (!Array.isArray(layer.layers)) {\n        return;\n    }\n\n    for (const subLayer of layer.layers) {\n        // drawing Sublayer\n        drawCanvasLayer({ ...args, layer: subLayer });\n    }\n}\n\nfunction drawObjectLayer(args: DrawCanvasLayerArgs<ObjectLayer>) {\n    const { layer, context: ctx } = args;\n\n    if (!Array.isArray(layer.objects)) {\n        return;\n    }\n\n    for (const obj of layer.objects) {\n        ctx.save();\n        ctx.translate(obj.x, obj.y);\n        // TODO: take care of rotation\n        if (isTilemapObject(obj)) {\n            // no idea what this is\n        } else if (isEllipse(obj)) {\n            ctx.ellipse(obj.width / 2, obj.height / 2, obj.width / 2, obj.height / 2, 0, 0, 2 * Math.PI);\n            ctx.stroke();\n        } else if (isPoint(obj)) {\n            ctx.rect(0, 0, 1, 1);\n            ctx.stroke();\n        } else if (isPolygon(obj)) {\n            ctx.beginPath();\n            const first = obj.polygon[0];\n            if (first) {\n                ctx.moveTo(first.x, first.y);\n            }\n            for (const { x, y } of obj.polygon) {\n                ctx.lineTo(x, y);\n            }\n            if (first) {\n                ctx.lineTo(first.x, first.y);\n            }\n            ctx.closePath();\n            ctx.stroke();\n        } else if (isPolyline(obj)) {\n            ctx.beginPath();\n            const first = obj.polyline[0];\n            if (first) {\n                ctx.moveTo(first.x, first.y);\n            }\n            for (const { x, y } of obj.polyline) {\n                ctx.lineTo(x, y);\n            }\n            ctx.closePath();\n            ctx.stroke();\n        } else if (isText(obj)) {\n            for (const value of Object.values(obj.text)) {\n                ctx.fillText(value, 0, 0);\n            }\n        } /* isRectangle(obj) */ else {\n            ctx.rect(0, 0, obj.width, obj.height);\n            ctx.stroke();\n        }\n        ctx.fillText(obj.name, 0, -5);\n        ctx.restore();\n    }\n}\n\nfunction drawImageLayer(args: DrawCanvasLayerArgs<ImageLayer>) {\n    throw 'drawing ImageLayers is not implemented yet!';\n}\n\nexport interface DrawCanvasTileArgs {\n    x: number;\n    y: number;\n    tileIndex: number;\n    context: CanvasRenderingContext2D;\n    tileSet: HTMLImageElement;\n    layer: Layer;\n    tsxJson: TsxJson;\n}\n\nfunction drawCanvasTile({\n    x,\n    y,\n    tileIndex,\n    context,\n    tileSet,\n    layer,\n    tsxJson: { columns: cols, tileheight, tilewidth, spacing }\n}: DrawCanvasTileArgs) {\n    const flip_horiz = 0x80000000 & tileIndex;\n    const flip_vert = 0x40000000 & tileIndex;\n    const flip_diag = 0x20000000 & tileIndex;\n    const realTileIndex = (tileIndex & 0x0fffffff) - 1;\n\n    const tileX = realTileIndex % cols;\n    const tileY = Math.floor(realTileIndex / cols);\n\n    const posX = x * tilewidth;\n    const posY = y * tileheight;\n\n    let left = (layer.x + tileX) * (tilewidth + spacing);\n    let top = (layer.y + tileY) * (tileheight + spacing);\n\n    context.translate(posX, posY);\n\n    if (flip_horiz) {\n        context.translate(tilewidth, 0);\n        context.scale(-1, 1);\n    }\n    if (flip_vert) {\n        context.translate(0, tileheight);\n        context.scale(1, -1);\n    }\n    if (flip_diag) {\n        context.rotate(Math.PI / 2);\n        context.scale(1, -1);\n    }\n\n    context.drawImage(tileSet, left, top, tilewidth, tileheight, 0, 0, tilewidth, tileheight);\n}\n","import { TmxJson, TileLayer, GroupLayer, Layer } from './model/tiled';\nimport { isTileLayer, isGroupLayer, isObjectLayer, isImageLayer } from './helpers';\nimport { Rectangle, GeometryObject } from './model/tiled-geometry-objects';\n\nexport function tileLayerToRectangles(layer: TileLayer, { tilewidth, tileheight }: TmxJson): Rectangle[] {\n    const rectMap: Array<Array<Rectangle>> = [];\n    const getRect = (x: number, y: number): Rectangle | undefined => (rectMap[y] || [])[x];\n    const setRect = (x: number, y: number, rect: Rectangle) => {\n        if (!rectMap[y]) {\n            rectMap[y] = [];\n        }\n        rectMap[y][x] = rect;\n    };\n\n    const accumulateLayer = (layer: TileLayer) => {\n        if (isTileLayer(layer) && layer.data) {\n            for (let dy = 0; dy < layer.height; dy++) {\n                for (let dx = 0; dx < layer.width; dx++) {\n                    const x = layer.x + dx;\n                    const y = layer.y + dy;\n                    const idx = dy * layer.width + dx;\n                    const value = layer.data[idx];\n\n                    if (value) {\n                        let rect: Rectangle = {\n                            id: (layer.id || 0) * 10000 + idx,\n                            name: '',\n                            type: '',\n                            x,\n                            y,\n                            width: 1,\n                            height: 1,\n                            visible: true\n                        };\n                        const left = getRect(x - 1, y);\n                        if (left && left.height === 1) {\n                            // grow right\n                            left.width++;\n                            rect = left;\n                        }\n\n                        const top = getRect(x, y - 1);\n                        if (top && top.x == rect.x && top.width === rect.width) {\n                            // grow bottom\n                            for (let x1 = rect.x; x1 < rect.x + rect.width; x1++) {\n                                setRect(x1, y, top);\n                            }\n                            top.height++;\n                            rect = top;\n                        }\n\n                        setRect(x, y, rect);\n                    }\n                }\n            }\n        }\n\n        const acc: Rectangle[] = [];\n        for (const row of rectMap) {\n            if (!row) {\n                continue;\n            }\n            for (const rect of row) {\n                if (rect && !acc.includes(rect)) {\n                    acc.push(rect);\n                }\n            }\n        }\n\n        return acc;\n    };\n\n    return accumulateLayer(layer).map(rect => ({\n        ...rect,\n        x: rect.x * tilewidth,\n        y: rect.y * tileheight,\n        width: rect.width * tilewidth,\n        height: rect.height * tileheight\n    }));\n}\n\nexport function layerToGeometryObjects(layer: Layer, tmxJson: TmxJson): Array<GeometryObject> {\n    if (isTileLayer(layer)) {\n        return tileLayerToRectangles(layer, tmxJson);\n    }\n    if (isObjectLayer(layer)) {\n        return layer.objects;\n    }\n    if (isGroupLayer(layer)) {\n        return layer.layers.reduce(\n            (acc, subLayer) => (acc.push(...layerToGeometryObjects(subLayer, tmxJson)), acc),\n            [] as Array<GeometryObject>\n        );\n    }\n    if (isImageLayer(layer)) {\n        return [];\n    }\n    return [];\n}\n","import { TsxJson, TmxJson, Layer, TileLayer } from './model/tiled';\nimport { isTileLayer } from './helpers';\n\nexport interface MapData {\n    tsxJson: TsxJson;\n    tmxJson: TmxJson;\n    tileSet: HTMLImageElement;\n}\n\nexport interface ExtraOptions {\n    decompressZlib?: (base64string: string) => number[];\n    decompressGzip?: (base64string: string) => number[];\n}\n\nexport async function loadMap(tmxJsonFilename: string, base: string, options: ExtraOptions = {}): Promise<MapData> {\n    const tmxJsonResult = await fetch(new URL(tmxJsonFilename, base).toString());\n    const tmxJson = (await tmxJsonResult.json()) as TmxJson;\n\n    tmxJson.layers = tmxJson.layers.map(layer => (isTileLayer(layer) ? normalizeLayer(options)(layer) : layer));\n\n    const tsxJsonResult = await fetch(new URL(tmxJson.tilesets[0].source, base).toString());\n    const tsxJson = (await tsxJsonResult.json()) as TsxJson;\n\n    const tileSet = document.createElement('img');\n    await new Promise(resolve => {\n        tileSet.onload = resolve;\n        tileSet.src = new URL(tsxJson.image, base).toString();\n    });\n    return { tmxJson, tsxJson, tileSet };\n}\n\nconst normalizeLayer = (options: ExtraOptions) => (layer: TileLayer): TileLayer => {\n    const normalizeWithDecompressionFn = (decompressionFn?: (_: string) => number[]) => {\n        if (!decompressionFn) {\n            throw new Error('encountered compressed data, but no correct decompression function was given!');\n        }\n        if (layer.data) {\n            layer.data = decompressionFn((layer.data as any) as string);\n        }\n        if (layer.chunks) {\n            layer.chunks.forEach(chunk => {\n                if (typeof chunk.data === 'string') chunk.data = decompressionFn(chunk.data);\n            });\n        }\n        layer.encoding = 'csv';\n        delete layer.compression;\n    };\n\n    if (layer.encoding === 'base64' && layer.compression === 'zlib') {\n        normalizeWithDecompressionFn(options.decompressZlib);\n    }\n    if (layer.encoding === 'base64' && layer.compression === 'gzip') {\n        normalizeWithDecompressionFn(options.decompressGzip);\n    }\n    return layer;\n};\n","export * from './canvas';\nexport { tileLayerToRectangles } from './geometry';\nexport { TmxJson, TsxJson, Layer, Tileset } from './model/tiled';\nexport { loadMap } from './loadMap';\nimport * as helpers from './helpers';\nexport { helpers };\n","import { loadMap, drawCanvasLayer } from 'tiled-canvas';\n\ndeclare global {\n    interface Window {\n        example1(canvas: HTMLCanvasElement): void;\n    }\n}\n\nconst baseDir = `${window.location.origin}${window.location.pathname}`.replace(/^(.*?)(\\/[^/]*\\.[^/]*)?$/, '$1');\n\nwindow.example1 = canvas => {\n    const context = canvas.getContext('2d');\n    if (!context) {\n        throw new Error('could not get context');\n    }\n\n    loadMap('island.tmx.json', `${baseDir}/rpg/`).then(basicConfig => {\n        for (const layer of basicConfig.tmxJson.layers) {\n            const layerConfig = {\n                ...basicConfig,\n                context,\n                layer\n            };\n            drawCanvasLayer(layerConfig);\n        }\n    });\n};\n"]}